# Quest 11. RDB의 기초와 ORM

## Introduction
* 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics
* RDBMS
* MySQL
* ORM
* Hash
  * scrypt

## Resources
* [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
* [Sequelize](https://sequelize.org/)
* [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist
* RDBMS 테이블의 정규화는 무엇인가요?
  * 관계형 데이터베이스에서 테이블을 정규화(normalization)한다는 것은 중복 데이터를 최소화하고 데이터 일관성을 유지하기 위해 테이블을 분해하는 과정을 말합니다. 이 과정은 데이터 중복을 최소화하면서 데이터의 일관성, 정확성, 유연성을 보장하기 위해 수행됩니다.

  정규화는 보통 1차 정규화, 2차 정규화, 3차 정규화, BCNF(Boyce-Codd 정규형) 등 다양한 단계로 나뉘어 수행됩니다. 이러한 단계별로 테이블을 분해하여 각각의 테이블이 특정 조건을 만족하도록 하는 것입니다.

  정규화의 목적은 데이터 일관성을 유지하고 데이터 중복을 최소화하여 데이터베이스의 용량을 최적화하는 것입니다. 이를 통해 데이터의 일관성과 정확성을 유지할 수 있고, 데이터 수정이나 삭제 작업이 더욱 효율적으로 이루어질 수 있습니다.

* MySQL 외의 RDB에는 어떤 것들이 있나요?
  * Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?
    * MySQL 외에도 다양한 RDB(Relational Database)가 존재합니다. 일부는 상용 소프트웨어이고, 일부는 오픈 소스이며, 다른 목적으로 사용되는 데이터베이스도 있습니다. 다음은 몇 가지 대표적인 RDB의 예입니다.

    Oracle Database: 대규모 데이터베이스에 적합한 상용 RDBMS입니다. 대규모 트랜잭션 처리 및 복잡한 데이터 처리 작업에 적합합니다.

    Microsoft SQL Server: 윈도우 플랫폼에 최적화된 RDBMS입니다. 사용하기 쉽고, 안정적입니다.

    PostgreSQL: 오픈 소스 RDBMS로, 대규모 데이터 처리와 높은 신뢰성을 제공합니다. 데이터 복제, 트리거 등 다양한 기능을 제공합니다.

    SQLite: 오픈 소스 RDBMS로, 작은 규모의 데이터베이스에 적합합니다. 모바일 앱, IoT 기기 등에 많이 사용됩니다.

    MariaDB: MySQL의 포크(fork) 버전으로, 오픈 소스 RDBMS입니다. 빠른 속도와 안정성을 제공하며, MySQL과 호환성이 높습니다.

    IBM DB2: 대규모 트랜잭션 처리와 고도로 복잡한 데이터 처리 작업에 적합한 상용 RDBMS입니다.

    이 외에도 Informix, Sybase 등 다양한 RDBMS가 있습니다. 선택할 RDBMS는 사용 목적, 처리 데이터 양, 예산 등 다양한 요인을 고려하여 결정해야 합니다.

* RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?
  * RDBMS에서 인덱싱(Indexing)은 데이터베이스에서 데이터를 검색할 때 데이터베이스 엔진이 데이터를 빠르게 찾을 수 있도록 하기 위한 방법 중 하나입니다. 인덱스는 데이터베이스의 테이블에 대한 검색 경로를 만들어, 검색 속도를 향상시키는 데 중요한 역할을 합니다.

  인덱스를 사용하면 다음과 같은 장점이 있습니다.

  검색 속도가 향상됩니다.
  정렬된 데이터를 반환하기 때문에, 정렬된 결과를 반환할 때 성능이 향상됩니다.
  데이터의 무결성을 유지할 수 있습니다.
  인덱스를 생성하면 데이터베이스가 더욱 효율적으로 작동하므로, 쿼리 실행 시 CPU와 메모리 사용량이 줄어듭니다.
  인덱스는 일반적으로 B-Tree(또는 B+Tree) 알고리즘을 사용하여 생성됩니다. 인덱스는 특정 열에 대한 값을 포함하고 있으며, 이 값을 사용하여 검색이 수행됩니다. 즉, 인덱스는 데이터베이스 내에 특정 열에 대한 참조를 만드는 것입니다. 인덱스는 특정 열의 값을 기반으로 정렬된 B-Tree 구조를 갖게 됩니다.

  인덱스를 만들 때는 인덱스를 생성할 열을 선택하고, 인덱스 타입과 크기를 선택해야 합니다. 인덱스 타입에는 B-Tree, Hash 등이 있으며, 인덱스 크기는 인덱스를 생성할 열의 데이터 타입과 열의 크기, 인덱스 타입 등에 따라 달라집니다.

  인덱스를 생성하면 데이터베이스는 데이터를 추가, 수정, 삭제할 때마다 인덱스도 함께 수정해야 합니다. 이로 인해 데이터베이스의 성능이 저하될 수 있으므로, 인덱스를 지나치게 많이 사용하면 안됩니다. 필요한 열에 대해서만 인덱스를 생성하는 것이 좋습니다.

* ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?
  * ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스 간의 데이터 매핑을 자동으로 처리하는 도구나 기술을 의미합니다. ORM을 사용하는 것은 직접 SQL문을 작성하여 데이터베이스에 접근하는 것보다 편리할 수 있습니다.

  * 장점:

  SQL 작성에 대한 노력을 줄여줍니다.
  객체 지향적인 코드 작성이 가능해집니다.
  데이터베이스 스키마 변경 시 ORM을 통해 일관된 코드 수정이 가능합니다.
  코드의 가독성이 좋아집니다.
  ORM은 대부분 캐싱 기능을 제공하기 때문에 데이터 조회 성능이 향상될 수 있습니다.
  * 단점:

  ORM을 사용하면 SQL의 성능 최적화를 하기 어려워집니다.
  ORM이 제공하는 기능 외의 작업이 필요할 경우에는 SQL을 직접 작성해야 할 때가 있습니다.
  ORM을 사용하는 경우, ORM이 가지는 복잡성 때문에 일부 개발자들이 성능 문제가 발생할 때 해결하기 어려워할 수 있습니다.
  종합적으로, ORM은 데이터베이스 접근과 관련된 작업을 쉽게 처리할 수 있지만, 일부 복잡한 경우에는 SQL을 직접 작성해야 하는 상황이 발생할 수 있습니다. 따라서 ORM의 사용 여부는 프로젝트의 특성과 상황에 따라 결정하는 것이 좋습니다.

  * 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?
    * 자바스크립트 생태계에서 사용되는 ORM(Object-Relational Mapping) 라이브러리에는 다음과 같은 것들이 있습니다.

    * Sequelize: Node.js를 위한 ORM으로 MySQL, PostgreSQL, SQLite, MSSQL 등 다양한 데이터베이스를 지원합니다.
    * TypeORM: TypeScript를 위한 ORM으로 MySQL, PostgreSQL, SQLite, MSSQL, Oracle, MongoDB 등 다양한 데이터베이스를 지원합니다.
    * Mongoose: MongoDB를 위한 ORM으로 NoSQL 데이터베이스를 다룰 수 있습니다.
    * Prisma: MySQL, PostgreSQL, SQLite 데이터베이스를 위한 ORM으로 타입 세이프한 쿼리 작성이 가능하며, Prisma Client를 이용한 쿼리를 제공합니다.
    * Waterline: NoSQL, SQL 데이터베이스를 지원하는 ORM으로 다양한 데이터베이스와 연동이 가능합니다.
    이 외에도 많은 ORM 라이브러리들이 있으며, 프로젝트의 요구사항에 따라 적합한 ORM을 선택하여 사용할 수 있습니다.

* 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?
  * 관계형 데이터베이스에서 모델간의 관계는 1:1, 1:N, N:M으로 나눌 수 있습니다.

    * 1:1 관계 : 1:1 관계란 하나의 모델이 다른 하나의 모델과 하나의 관계만을 가지는 것을 말합니다. 이 경우 각 모델은 다른 모델을 참조하는 외래키(foreign key)를 가지게 됩니다. 이러한 관계는 주로 각각의 모델이 자주 함께 사용되어 하나의 테이블에 모두 저장할 경우 불필요한 데이터가 많아지는 경우에 사용됩니다.

    * 1:N 관계 : 1:N 관계란 한 모델이 다른 모델과 여러 개의 관계를 가지는 것을 말합니다. 예를 들어, 하나의 게시글은 여러 개의 댓글을 가질 수 있습니다. 이 경우 게시글 모델은 댓글 모델을 참조하는 외래키를 가지게 됩니다. 이러한 관계는 주로 다대일(다대다) 관계가 필요하지 않은 경우 사용됩니다.

    * N:M 관계 : N:M 관계란 한 모델이 다른 모델과 여러 개의 관계를 가지고, 반대쪽 모델도 다른 모델과 여러 개의 관계를 가지는 것을 말합니다. 예를 들어, 여러 명의 사용자가 여러 개의 그룹에 속할 수 있습니다. 이 경우 사용자와 그룹은 서로를 참조하는 외래키를 가지게 됩니다. 이러한 관계는 주로 다대다 관계를 나타내기 위해 사용됩니다.

    * 각각의 관계는 데이터의 구조와 사용 목적에 따라 선택되어야 합니다. 1:1 관계는 불필요한 데이터를 줄일 수 있고, 1:N 관계는 다른 모델과의 관계가 많은 경우 사용하기 적합하며, N:M 관계는 다대다 관계를 나타낼 때 사용됩니다.

* DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
  * DB에 사용자의 암호를 평문으로 저장하는 것은 보안상 매우 취약합니다. 따라서 보안을 강화하기 위해 사용자의 암호를 해시(hash)하여 저장합니다.

  해싱은 임의의 길이의 메시지를 고정된 길이의 값으로 변환하는 함수입니다. 이 변환된 값은 해시값이라고 하며, 입력값이 조금만 달라져도 완전히 다른 값이 생성됩니다. 해싱 함수는 일반적으로 일방향 함수이므로 해시값으로부터 입력값을 역추적하는 것은 매우 어렵습니다.

  따라서 사용자가 로그인 시 입력한 암호를 해싱하여 DB에 저장한 해시값과 비교하여 인증하는 것이 가능합니다. 이 때, 같은 암호를 입력했더라도 해싱 함수의 결과는 항상 같으므로 저장된 해시값과 비교하여 인증이 가능합니다.

  또한, 보안을 강화하기 위해 단순한 해싱만으로는 충분하지 않으며, 솔트(salt)라는 값을 추가하여 해싱하는 것이 일반적입니다. 솔트는 임의의 문자열로, 사용자마다 고유한 솔트값을 사용하여 암호를 해시하는 방식입니다. 이렇게 함으로써 같은 암호를 사용하더라도 다른 솔트값이 적용되므로 해시값이 달라져 보안성이 향상됩니다.

  * 해시 함수에는 어떤 것이 있나요?
    * 해시 함수는 임의의 길이의 입력을 받아서 고정된 길이의 출력을 생성하는 함수입니다. 일반적으로 해시 함수는 다음과 같은 특성을 가집니다.

    * 충돌 방지: 서로 다른 입력에 대해 같은 출력이 나오지 않도록 해야 합니다.
    * 일방향성: 출력으로부터 입력을 유추하는 것이 불가능해야 합니다.
    * 무결성: 입력이 조금이라도 바뀌면 출력도 완전히 달라져야 합니다.
    
    대표적인 해시 함수로는 다음과 같은 것들이 있습니다.
    * MD5 (Message-Digest Algorithm 5)
    * SHA-1 (Secure Hash Algorithm 1)
    * SHA-256 (Secure Hash Algorithm 256)
    하지만 최근에는 보안에 더 강력한 해시 함수가 필요해지면서, SHA-3, BLAKE2 등의 새로운 해시 함수가 개발되었습니다.
  * 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?
    * 사용자의 암호를 해싱하여 저장할 때에는 다음과 같은 방법들이 보안에 좋습니다.

    * 솔팅(Salting): 각각의 사용자 암호에 대해 유일한 값을 추가하여 암호화를 진행합니다. 이렇게 함으로써 동일한 암호를 가진 사용자의 데이터가 같은 형태로 저장되는 것을 방지할 수 있습니다. 예를 들어, 사용자가 "password"라는 암호를 사용한다면, 이 암호에 대해 무작위의 문자열을 추가하여 "password+salt"와 같은 형태로 저장할 수 있습니다.

    * 스트레칭(Stretching): 해시 함수를 여러 번 반복하여 암호화하는 방법입니다. 이 방법을 통해 해시 함수를 일반적인 방법보다 더 많이 사용하여, 더욱 강력한 보안성을 제공할 수 있습니다.

    * 안전한 해시 함수 사용: MD5, SHA-1과 같은 해시 함수는 보안에 취약한 점이 있으므로 사용하지 않는 것이 좋습니다. 대신, SHA-256, SHA-512와 같은 안전한 해시 함수를 사용하는 것이 좋습니다.

    위와 같은 방법들을 적용하여 암호를 해싱하여 저장하면, 암호를 평문으로 저장하는 것보다 보안성이 높아지며, 사용자의 데이터를 안전하게 보호할 수 있습니다.


## Quest
* 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  * 적절한 테이블을 설계해 보세요.
  * Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  * 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced
* Object–relational impedance mismatch란 어떤 개념인가요?
* Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
* 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
