# Quest 04. OOP의 기본

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍에 대해 알아볼 예정입니다.

## Topics
* 객체지향 프로그래밍
  * 프로토타입 기반 객체지향 프로그래밍
  * 자바스크립트 클래스
    * 생성자
    * 멤버 함수
    * 멤버 변수
  * 정보의 은폐
  * 다형성
* 코드의 재사용

## Resources
* [MDN - Classes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)
* [MDN - Inheritance and the prototype chain](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
* [MDN - Inheritance](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance)
* [Polymorphism](https://medium.com/@viktor.kukurba/object-oriented-programming-in-javascript-3-polymorphism-fb564c9f1ce8)
* [Class Composition](https://alligator.io/js/class-composition/)
* [Inheritance vs Composition](https://woowacourse.github.io/javable/post/2020-05-18-inheritance-vs-composition/)

## Checklist
* 객체지향 프로그래밍은 무엇일까요?
  *객체지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 한 패러다임으로, 객체(object)라는 개념을 중심으로 프로그래밍하는 방식입니다. 객체란 실제 세계에 존재하는 것들을 소프트웨어에 모델링한 것으로, 객체는 데이터와 그 데이터를 처리하는 메소드(method)로 구성됩니다.
  
  객체지향 프로그래밍에서는 프로그램을 여러 개의 객체로 나누어 생각합니다. 이러한 객체들은 각자 독립적으로 존재하며, 다른 객체들과 상호작용할 수 있습니다. 이러한 상호작용은 객체들 간의 메시지 전달을 통해 이루어지며, 객체들은 자신이 수신한 메시지에 대해 적절한 응답을 합니다.
  
  객체지향 프로그래밍은 코드의 재사용성과 유지보수성을 높여주는 등의 장점이 있습니다. 또한, 객체지향 프로그래밍은 상속(inheritance), 다형성(polymorphism), 캡슐화(encapsulation)와 같은 개념을 제공하여 프로그래밍의 복잡성을 낮출 수 있습니다. 이러한 장점들 때문에 객체지향 프로그래밍은 현재까지도 많이 사용되고 있습니다

  * `#`로 시작하는 프라이빗 필드는 왜 필요한 것일까요? 정보를 은폐(encapsulation)하면 어떤 장점이 있을까요?
    * #로 시작하는 프라이빗 필드는 ECMAScript 2019부터 추가된 기능으로, 해당 필드에 접근할 수 있는 권한을 클래스 외부로부터 제한함으로써 정보 은폐를 할 수 있게 해줍니다.
    
    정보 은폐는 객체지향 프로그래밍의 중요한 개념 중 하나로, 객체의 내부 구현을 외부에 노출시키지 않는 것을 말합니다. 이를 통해 코드의 안정성과 보안성을 높일 수 있습니다. 외부에서 객체의 상태를 직접 변경하는 것이 불가능해지므로 객체의 일관성을 유지할 수 있습니다. 또한, 객체의 내부 구현이 변경되더라도 외부에 영향을 미치지 않으므로 코드의 유연성과 확장성이 높아집니다.
   
    바닐라 자바스크립트에서는 프라이빗 필드를 구현하기 위해 #를 사용할 수 있지만, 이전에는 주로 약속된 규칙(convention)을 통해 프라이빗 필드를 구현했습니다. 예를 들어, _로 시작하는 필드는 외부에서 직접 접근하지 않아야 한다는 약속입니다.
    
    정보 은폐는 코드의 가독성을 떨어뜨리기도 하므로, 적절한 수준에서 사용해야 합니다. 모든 필드를 프라이빗으로 만들면 객체간의 상호작용이 어려워질 수 있습니다. 따라서, 객체의 구현 세부사항 중에서 외부에 노출해도 되는 것과 그렇지 않은 것을 구분하여 적절히 사용해야 합니다.
  
  * 다형성이란 무엇인가요? 다형성은 어떻게 코드 구조의 정리를 도와주나요?
    * 다형성(Polymorphism)이란, 같은 타입 또는 인터페이스를 구현한 여러 객체들이 그 객체들에 대한 동일한 메소드 호출에 대해 각자 다른 방식으로 응답하는 것을 말합니다.
    즉, 다형성은 객체지향 프로그래밍의 특성 중 하나로, 하나의 메소드나 인터페이스를 여러 개의 구현체가 다양한 방식으로 구현할 수 있도록 해줍니다. 이를 통해 같은 코드를 사용하더라도 다양한 객체들에 대해 일관된 방식으로 작업할 수 있습니다.
    
    다형성은 코드 구조의 정리를 도와줍니다. 예를 들어, 다형성을 사용하면 객체지향 프로그래밍에서 많이 사용되는 추상화(abstraction) 개념을 적용할 수 있습니다. 추상화는 공통된 특성을 가진 객체들을 일반화하여 상위 개념으로 나타내는 것을 말합니다. 이러한 추상화를 통해 코드를 단순화하고, 재사용성과 유지보수성을 높일 수 있습니다.
    
    또한, 다형성은 코드의 확장성을 높이는 데도 도움을 줍니다. 새로운 클래스나 인터페이스를 추가해도 이미 작성된 코드들이 영향을 받지 않도록 하기 위해 인터페이스와 다형성을 활용할 수 있습니다. 이를 통해 기존 코드를 수정하지 않고도 새로운 코드를 추가하거나 기존 코드를 대체할 수 있습니다.
    
    종합적으로, 다형성은 코드의 재사용성과 유지보수성을 높이고, 코드 구조의 단순화와 확장성을 높이는 데 도움을 줍니다. 따라서, 객체지향 프로그래밍에서 다형성을 적절히 사용하는 것은 좋은 프로그래밍 습관 중 하나입니다.
  
  * 상속이란 무엇인가요? 상속을 할 때의 장점과 단점은 무엇인가요?
    * 상속(Inheritance)은 객체지향 프로그래밍에서 기존 클래스를 재사용하여 새로운 클래스를 만드는 것을 말합니다. 상속 관계에서 기존 클래스는 부모 클래스(Parent Class) 또는 상위 클래스(Superclass)라고 하며, 새로운 클래스는 자식 클래스(Child Class) 또는 하위 클래스(Subclass)라고 합니다.
    * 장점 : 1) 코드의 재사용성: 기존 클래스에서 구현한 기능을 재사용하여 새로운 클래스를 작성할 수 있으므로 코드를 중복해서 작성하지 않아도 됩니다.

    2) 코드의 확장성: 부모 클래스의 기능을 변경하거나 새로운 기능을 추가하여 자식 클래스를 작성할 수 있으므로 코드의 확장성이 높아집니다.

    3) 코드의 유지보수성: 부모 클래스에서 수정한 내용이 자식 클래스에 자동으로 적용되므로 유지보수가 용이합니다.
    * 단점 : 1) 코드의 복잡도: 상속을 통해 클래스 계층 구조가 복잡해질 수 있습니다. 이러한 복잡도는 코드의 이해와 유지보수를 어렵게 만들 수 있습니다.

    2) 결합도의 증가: 부모 클래스와 자식 클래스 간의 결합도가 높아지므로, 부모 클래스의 변경이 자식 클래스에 영향을 미칠 수 있습니다.

    3) 오버라이딩의 오용: 자식 클래스에서 부모 클래스의 메소드를 오버라이딩하면 부모 클래스의 기능을 덮어쓰게 됩니다. 이러한 오버라이딩이 오용될 경우 부모 클래스의 기능을 변경하기 어려워질 수 있습니다.
  
  * OOP의 합성(Composition)이란 무엇인가요? 합성이 상속에 비해 가지는 장점은 무엇일까요?
    * 객체지향 프로그래밍(OOP)에서 합성(Composition)은 객체를 다른 객체의 구성요소로 사용하는 것을 말합니다. 합성을 사용하면 기존 클래스를 재사용하는 것보다 더 유연한 코드를 작성할 수 있습니다.
    * 장점 : 1) 코드의 재사용성: 합성을 통해 객체를 다른 객체의 구성요소로 사용하기 때문에 코드의 재사용성이 높아집니다.

    2) 코드의 유지보수성: 합성을 사용하면 객체를 변경하더라도 다른 객체에 영향을 미치지 않으므로 유지보수가 용이합니다.

    3) 결합도의 낮춤: 합성을 사용하면 객체 간의 결합도를 낮출 수 있습니다. 객체 간의 결합도가 낮아지면 객체를 독립적으로 테스트하거나 재사용할 수 있습니다.

    4) 코드의 확장성: 합성을 사용하면 객체를 새로운 객체의 구성요소로 사용하여 새로운 기능을 추가할 수 있습니다. 이러한 코드의 확장성은 상속보다 더 높아집니다.

    5) 다형성 지원: 합성을 사용하면 다형성을 지원할 수 있습니다. 객체를 다른 객체의 구성요소로 사용할 때, 인터페이스를 정의하여 다형성을 지원할 수 있습니다.

    * 상속과 달리 합성은 기존 클래스의 코드를 재사용하지 않고, 객체를 다른 객체의 구성요소로 사용하여 유연한 코드를 작성할 수 있습니다. 또한, 객체 간의 결합도를 낮출 수 있으므로 객체를 독립적으로 테스트하거나 재사용할 수 있습니다. 이러한 장점들로 인해, 합성은 상속에 비해 더 유용한 프로그래밍 기법 중 하나입니다.

* 자바스크립트의 클래스는 어떻게 정의할까요?
  *ECMAScript 2015(ES6)부터 자바스크립트는 클래스(class) 문법을 지원합니다. 클래스를 정의하는 방법은 다음과 같습니다.
  ```
  javascript
  
  class MyClass {
    // 클래스 멤버 변수
    constructor(param1, param2) {
      this.param1 = param1;
      this.param2 = param2;
    }

    // 클래스 메소드
    myMethod() {
      console.log("Hello, world!");
    }
  }

  // 객체 생성
  const myObj = new MyClass("value1", "value2");
  ```
  * 위의 코드에서 MyClass는 클래스 이름이며, constructor는 클래스의 생성자입니다. 생성자는 객체가 생성될 때 호출되는 함수이며, 클래스의 멤버 변수를 초기화하는 역할을 합니다. 클래스 멤버 변수는 this 키워드를 사용하여 정의하며, 클래스 메소드는 일반 함수와 같이 정의할 수 있습니다.

  클래스를 생성한 후에는 new 키워드를 사용하여 객체를 생성할 수 있습니다. `new` 키워드를 사용하여 객체를 생성할 때는 생성자에 전달할 인수를 함께 전달합니다.

  위의 예제에서는 myObj라는 객체를 생성하고 있으며, MyClass의 생성자에 "value1"과 "value2"라는 인수를 전달하고 있습니다. 생성된 객체는 myObj 변수에 할당됩니다.

  ES6 이전 버전의 자바스크립트에서는 클래스 문법이 없었기 때문에 함수를 사용하여 클래스와 비슷한 구조를 만들어 사용하는 경우가 많았습니다. 이러한 방법을 프로토타입 기반 상속(Prototype-based Inheritance)이라고 합니다.

  * 프로토타입 기반의 객체지향 프로그래밍은 무엇일까요?
    * 프로토타입 기반의 객체지향 프로그래밍은 클래스(class)가 아닌 프로토타입(prototype)을 이용하여 객체를 생성하는 객체지향 프로그래밍 패러다임입니다. 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍을 지원합니다.

    객체의 프로토타입은 다른 객체를 참조하는 링크로 구현됩니다. 즉, 어떤 객체를 생성할 때 해당 객체의 프로토타입을 참조하여 필요한 속성과 메소드를 상속받는 것입니다. 객체의 프로토타입은 객체 생성 후에도 동적으로 변경할 수 있습니다.

    프로토타입 기반의 객체지향 프로그래밍에서는 클래스(class) 개념이 없으며, 대신 생성자 함수(constructor function)를 이용하여 객체를 생성합니다. 생성자 함수는 new 키워드를 이용하여 객체를 생성하며, 객체를 초기화하는 코드를 포함할 수 있습니다.
    ```
    javascript
    Copy code
    function Person(name) {
      this.name = name;
    }

    Person.prototype.greet = function() {
      console.log(`Hello, my name is ${this.name}`);
    }

    const person1 = new Person('Alice');
    person1.greet(); // 출력: "Hello, my name is Alice"
    ```
    위의 예제에서 Person 함수는 생성자 함수입니다. Person 함수의 prototype 프로퍼티에 greet 메소드를 추가하여 Person 생성자 함수로부터 생성된 모든 객체에서 greet 메소드를 사용할 수 있도록 만들었습니다.

    person1 객체는 Person 생성자 함수를 이용하여 생성되었습니다. person1 객체는 Person 함수에서 정의한 name 프로퍼티를 가지고 있으며, Person.prototype에 정의한 greet 메소드를 사용할 수 있습니다.

    프로토타입 기반의 객체지향 프로그래밍은 클래스 기반의 객체지향 프로그래밍과 달리 상속을 구현하기 위해 프로토타입 체인(prototype chain)이라는 구조를 이용합니다. 이 구조는 객체의 프로토타입이 다른 객체를 참조하는 링크로 구현되어 있으며, 객체를 생성할 때 해당 객체의 프로토타입을 지정하여 상속을 구현할 수 있습니다
  
  * 자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 어떤 관계를 가지고 있나요?
    * 자바스크립트의 클래스는 프로토타입 기반의 객체지향 구현을 간단하게 하기 위한 문법적인 설탕(syntactic sugar)으로서, 기존의 프로토타입 기반의 객체지향 구현과 밀접한 관계를 가지고 있습니다.

    ES6(ES2015)에서 도입된 클래스 문법은 프로토타입 기반의 객체지향 프로그래밍에서 생성자 함수와 프로토타입을 쉽게 작성할 수 있도록 하는 문법적인 형태를 제공합니다. 클래스를 이용하여 객체를 생성할 때 내부적으로는 생성자 함수와 프로토타입 체인을 이용하여 객체를 생성합니다.
   
    * ES6에서 클래스 문법이 도입되기 이전에도, 프로토타입을 이용하여 객체를 생성하고 상속을 구현하는 것이 가능했습니다. 따라서 클래스 문법은 기존의 프로토타입 기반의 객체지향 구현과 상호 호환성이 있으며, 클래스를 이용한 객체 생성 방식과 기존의 프로토타입 기반의 객체 생성 방식은 동일한 결과를 출력합니다.
## Quest
* 웹 상에서 동작하는 간단한 바탕화면 시스템을 만들 예정입니다.
* 요구사항은 다음과 같습니다:
  * 아이콘은 폴더와 일반 아이콘, 두 가지의 종류가 있습니다.
  * 아이콘들을 드래그를 통해 움직일 수 있어야 합니다.
  * 폴더 아이콘은 더블클릭하면 해당 폴더가 창으로 열리며, 열린 폴더의 창 역시 드래그를 통해 움직일 수 있어야 합니다.
  * 바탕화면의 생성자를 통해 처음에 생겨날 아이콘과 폴더의 개수를 받을 수 있습니다.
  * 여러 개의 바탕화면을 각각 다른 DOM 엘리먼트에서 동시에 운영할 수 있습니다.
  * Drag & Drop API를 사용하지 말고, 실제 마우스 이벤트(mouseover, mousedown, mouseout 등)를 사용하여 구현해 보세요!

## Advanced
* 객체지향의 역사는 어떻게 될까요?
* Smalltalk, Java, Go, Kotlin 등의 언어들로 넘어오면서 객체지향 패러다임 측면에서 어떤 발전이 있었을까요?
